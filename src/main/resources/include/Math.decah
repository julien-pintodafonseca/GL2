// Grenoble INP - Ensimag
// Projet Génie Logiciel 2020, Equipe GL2
// Library for class Math of Deca, coded in Deca

class Math {
    float PI = 3.14159265358979323846;
    float MAX_VALUE = 3.40282 * _pow(10,38);
    float MIN_VALUE = 1.40130 * _pow(10,-45);
    int SIGNIFICAND_WIDTH = 24;
    int MAX_EXPONENT = 127;
    int MIN_EXPONENT = -126;

    float ulp(float f) {
        int exp = _getExponent(f);

        if (exp == MAX_EXPONENT+1) {
            return _abs(f);
        } else if (exp == MIN_EXPONENT-1) {
            return MIN_VALUE;
        } else {
            exp = exp - (SIGNIFICAND_WIDTH-1);
            if (exp >= MIN_EXPONENT) {
                return _pow(2,exp);
            } else {
                // pas trop sûr mais ça semble bien
                return MIN_VALUE;
            }
        }
    }

    float _getMaxValue() {
        return MAX_VALUE;
    }

    float _getMinValue() {
        return MIN_VALUE;
    }

    int _getExponent(float x) {
        int e = 0;
        x = _abs(x);
        if (x <= MIN_VALUE || x == 0) {
            return MIN_EXPONENT-1;
        } else if (x >= MAX_VALUE) {
            return MAX_EXPONENT;
        } else {
            while (_pow(2,e) <= x) {
                e = e+1;
            }
            return e-1;
        }
    }

    float _abs(float x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
    }

    float _pow(float x, int e) {
        float p;
        if (e == 0) {
            return 1;
        } else {
            p = _pow(x, e/2);

            if (e%2 == 0) {
                return p*p;
            } else if (e > 0) {
                return x*(p*p);
            } else {
                return (p*p)/x;
            }
        }
    }

    float sin(float rad) {
        float deg;
        int quadrant;
        int sign;
        float sine;

        // 1. We use periodicity
        // If we don't have 0 <= deg <= 360
        deg = _toDegrees(rad);
        if (!(deg >= 0 && deg < 360)) {
            deg = (int)(deg)%360;
        }

        // 2. We use symmetry
        // If quadrant isn't equal to 1
        quadrant = ((int)(deg)/90)%4 + 1;
        sign=0; // by default we want to return +sin(deg)
        if (quadrant != 1) {
            while (_abs(deg-180) < _abs(deg)) {
                deg = deg-180;
            }
            if (quadrant != 2) {
                sign=1; // we want to return -sin(deg)
            }
        }

        // 3. We use the cofunction
        // If we have 45 <= deg <= 90
        if (!(deg < 45)) {
            // instead of calculating sin(x) we will calculate cos(90°-x)
            // sine = cos(_toRadians(90)-_toRadians(deg));
            // if (sign == 0) {
            //    return sine;
            // } else {
            //    return -sine;
            // }
        }

        // 4. We use the sine polynomial (based on Taylor's series)
        // If we have 0 <= deg < 45
        sine = _toRadians(deg) - _pow(_toRadians(deg),3)/6 + _pow(_toRadians(deg),5)/120;
        if (sign == 0) {
            return sine;
        } else {
            return -sine;
        }
    }

    float cos(float rad) {
        println("cos(rad) not yet implemented");
    }

    float asin(float rad) {
        println("asin(rad) not yet implemented");
    }

    float atan(float rad) {
        println("atan(rad) not yet implemented");
    }

    float _getPI() {
        return PI;
    }

    float _toDegrees(float rad) {
        return (rad*180.0)/PI;
    }

    float _toRadians(float deg) {
        return (deg/180.0)*PI;
    }
}

// End of Deca Math library
